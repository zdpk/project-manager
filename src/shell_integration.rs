use anyhow::{anyhow, Result};
use chrono::Utc;
use dirs;
use inquire::{Confirm, Select};
use std::path::{Path, PathBuf};
use tokio::fs;
use crate::backup::{BackupEntry, BackupReason, create_multi_file_backup};
use crate::utils;

#[derive(Debug, Clone)]
enum ConflictAction {
    Backup,
    Remove,
    Cancel,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum ShellType {
    Fish,
    Zsh,
    Bash,
    Unknown,
}

/// Detects the current shell type
pub fn detect_shell() -> ShellType {
    if std::env::var("FISH_VERSION").is_ok()
        || std::env::var("SHELL")
            .map(|s| s.ends_with("/fish"))
            .unwrap_or(false)
    {
        ShellType::Fish
    } else if std::env::var("ZSH_VERSION").is_ok()
        || std::env::var("SHELL")
            .map(|s| s.ends_with("/zsh"))
            .unwrap_or(false)
    {
        ShellType::Zsh
    } else if std::env::var("BASH_VERSION").is_ok()
        || std::env::var("SHELL")
            .map(|s| s.ends_with("/bash"))
            .unwrap_or(false)
    {
        ShellType::Bash
    } else {
        ShellType::Unknown
    }
}

/// Legacy helper functions for backward compatibility
pub fn is_fish_shell() -> bool {
    matches!(detect_shell(), ShellType::Fish)
}

pub fn is_zsh_shell() -> bool {
    matches!(detect_shell(), ShellType::Zsh)
}

pub fn is_bash_shell() -> bool {
    matches!(detect_shell(), ShellType::Bash)
}

/// Check if shell integration exists for the given shell type
pub fn shell_integration_exists(shell_type: &ShellType) -> bool {
    match shell_type {
        ShellType::Fish => fish_function_exists(),
        ShellType::Zsh => zsh_integration_exists(),
        ShellType::Bash => bash_integration_exists(),
        ShellType::Unknown => false,
    }
}

/// Check if Fish function file exists
fn fish_function_exists() -> bool {
    let fish_functions_dir = dirs::home_dir()
        .map(|home| home.join(".config/fish/functions"))
        .unwrap_or_default();
    fish_functions_dir.join("pm.fish").exists()
}

/// Check if Zsh integration exists
fn zsh_integration_exists() -> bool {
    let config_dir = dirs::home_dir()
        .map(|home| home.join(".config/pm"))
        .unwrap_or_default();
    let zsh_file = config_dir.join("pm.zsh");
    
    if !zsh_file.exists() {
        return false;
    }
    
    // Check if .zshrc sources the file
    let zshrc_path = dirs::home_dir()
        .map(|home| home.join(".zshrc"))
        .unwrap_or_default();
    
    if let Ok(content) = std::fs::read_to_string(zshrc_path) {
        content.contains("source ~/.config/pm/pm.zsh") || content.contains(". ~/.config/pm/pm.zsh")
    } else {
        false
    }
}

/// Check if Bash integration exists
fn bash_integration_exists() -> bool {
    let config_dir = dirs::home_dir()
        .map(|home| home.join(".config/pm"))
        .unwrap_or_default();
    let bash_file = config_dir.join("pm.bash");
    
    if !bash_file.exists() {
        return false;
    }
    
    // Check if .bashrc sources the file
    let bashrc_path = dirs::home_dir()
        .map(|home| home.join(".bashrc"))
        .unwrap_or_default();
    
    if let Ok(content) = std::fs::read_to_string(bashrc_path) {
        content.contains("source ~/.config/pm/pm.bash") || content.contains(". ~/.config/pm/pm.bash")
    } else {
        false
    }
}

/// Handle conflict when existing Fish function is found
async fn handle_fish_function_conflict(existing_path: &Path) -> Result<ConflictAction> {
    println!("‚ö†Ô∏è  Found existing Fish function: {}", existing_path.display());

    let existing_content = fs::read_to_string(existing_path).await?;
    let is_pm_generated = existing_content.contains("# Generated by PM v");

    if is_pm_generated {
        println!("üîÑ Existing file was generated by PM - will update automatically");
        return Ok(ConflictAction::Remove);
    }

    // Show preview of existing function (first 5 lines)
    let preview_lines: Vec<&str> = existing_content.lines().take(5).collect();
    println!("\nüìã Current function preview:");
    for (i, line) in preview_lines.iter().enumerate() {
        println!("   {}: {}", i + 1, line);
    }
    if existing_content.lines().count() > 5 {
        println!(
            "   ... ({} more lines)",
            existing_content.lines().count() - 5
        );
    }

    let options = vec![
        "Backup existing and install PM integration",
        "Remove existing and install PM integration",
        "Cancel installation",
    ];

    let selection = Select::new("How would you like to proceed?", options)
        .with_help_message("Choose how to handle the existing pm.fish function")
        .prompt()?;

    match selection {
        "Backup existing and install PM integration" => Ok(ConflictAction::Backup),
        "Remove existing and install PM integration" => Ok(ConflictAction::Remove),
        "Cancel installation" => Ok(ConflictAction::Cancel),
        _ => unreachable!(),
    }
}

/// Create backup of existing function file
async fn backup_existing_function(original_path: &Path) -> Result<PathBuf> {
    let timestamp = Utc::now().format("%Y%m%d_%H%M%S");
    let backup_path = original_path.with_file_name(format!("pm.fish.backup.{}", timestamp));

    // Handle case where backup filename already exists
    let mut counter = 1;
    let mut final_backup_path = backup_path.clone();
    while final_backup_path.exists() {
        final_backup_path = original_path
            .with_file_name(format!("pm.fish.backup.{}.{}", timestamp, counter));
        counter += 1;
    }

    fs::copy(original_path, &final_backup_path).await?;
    println!("üíæ Backed up to: {}", final_backup_path.display());

    Ok(final_backup_path)
}

/// Generate Fish function content (supports both production and development modes)
fn create_fish_function_content(is_dev: bool) -> String {
    let (shell_name, function_name, binary_logic, usage_info) = if is_dev {
        ("Fish shell integration (Development Mode)", "_pm", 
         r#"# Always use _pm binary for development
    set pm_bin (command -v _pm)
    
    # Development version uses separate config: ~/.config/pm/config-dev.yml"#,
         r#"# To remove this integration:
#   rm ~/.config/fish/functions/_pm.fish
#
# To disable temporarily:
#   functions -e _pm"#)
    } else {
        ("Fish shell integration", "pm", 
         r#"# Always use pm binary for production
    set pm_bin (command -v pm)"#,
         r#"# To remove this integration:
#   rm ~/.config/fish/functions/pm.fish
#
# To disable temporarily:
#   functions -e pm"#)
    };

    format!(
        r#"# Generated by PM v{} - {}
# This function enables directory switching with '{} sw'
#
{}

function {}
    {}
    
    if test "$argv[1]" = "sw" -o "$argv[1]" = "switch"
        set pm_output ($pm_bin $argv 2>&1)
        set pm_status $status
        
        if test $pm_status -eq 0
            # Extract directory from PM output
            set new_dir (echo $pm_output | grep "Switched to:" | sed 's/.*Switched to: //')
            if test -n "$new_dir" -a -d "$new_dir"
                cd "$new_dir"
                echo "üìÅ Changed directory to: $new_dir"
            else
                echo $pm_output
            end
        else
            echo $pm_output
        end
        
        return $pm_status
    else
        $pm_bin $argv
    end
end"#,
        env!("CARGO_PKG_VERSION"),
        shell_name,
        function_name,
        usage_info,
        function_name,
        binary_logic
    )
}

/// Setup Fish shell integration
async fn setup_fish_integration() -> Result<()> {
    let fish_functions_dir = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not find home directory"))?
        .join(".config/fish/functions");

    let pm_fish_path = fish_functions_dir.join("pm.fish");

    // Handle existing file conflict
    if pm_fish_path.exists() {
        match handle_fish_function_conflict(&pm_fish_path).await? {
            ConflictAction::Backup => {
                let backup_path = backup_existing_function(&pm_fish_path).await?;
                println!(
                    "üí° To restore: mv {} {}",
                    backup_path.display(),
                    pm_fish_path.display()
                );
            }
            ConflictAction::Remove => {
                fs::remove_file(&pm_fish_path).await?;
                println!("üóëÔ∏è  Removed existing pm.fish function");
            }
            ConflictAction::Cancel => {
                println!("‚ùå Fish integration setup cancelled");
                println!("üí° You can manually add PM integration to your existing function");
                return Ok(());
            }
        }
    }

    // Create directory and write new function file
    fs::create_dir_all(&fish_functions_dir).await?;

    let pm_fish_content = create_fish_function_content(false); // Production mode
    fs::write(&pm_fish_path, pm_fish_content).await?;

    let binary_name = utils::get_binary_name();
    println!("üê† Fish shell integration installed successfully");
    println!("   Function file: {}", pm_fish_path.display());
    println!("   Usage: {} sw <project> will now change your shell directory", binary_name);

    Ok(())
}

/// Setup shell integration for init command
pub async fn setup_shell_integration_for_init() -> Result<()> {
    let shell_type = detect_shell();
    
    match shell_type {
        ShellType::Unknown => {
            println!("‚ùì Unknown shell detected");
            println!("üí° Current shell: {}", std::env::var("SHELL").unwrap_or_default());
            println!("üí° Manual setup may be required");
            return Ok(());
        }
        _ => {}
    }
    
    let shell_name = match shell_type {
        ShellType::Fish => "Fish",
        ShellType::Zsh => "Zsh", 
        ShellType::Bash => "Bash",
        ShellType::Unknown => "Unknown",
    };
    
    // Check if integration already exists
    if shell_integration_exists(&shell_type) {
        println!("üîß {} shell integration already exists", shell_name);
        return Ok(());
    }
    
    let should_setup = Confirm::new(&format!("Setup {} shell integration for directory switching?", shell_name))
        .with_default(true)
        .with_help_message(&format!("This will allow '{} sw' to change your shell's current directory", utils::get_binary_name()))
        .prompt()?;

    if !should_setup {
        println!("‚è≠Ô∏è  Skipped shell integration setup");
        println!("üí° You can manually setup later or run '{} init' again", utils::get_binary_name());
        return Ok(());
    }

    match shell_type {
        ShellType::Fish => setup_fish_integration().await?,
        ShellType::Zsh => setup_zsh_integration().await?,
        ShellType::Bash => setup_bash_integration().await?,
        ShellType::Unknown => unreachable!(),
    }

    Ok(())
}

/// Create POSIX shell function content (works for both Bash and Zsh)
fn create_posix_shell_function_content(is_dev: bool) -> String {
    let (shell_name, function_name, binary_logic) = if is_dev {
        ("POSIX shell integration (Development Mode)", "_pm", 
         r#"# Always use _pm binary for development
    local pm_bin=$(command -v _pm)
    
    # Development version uses separate config: ~/.config/pm/config-dev.yml"#)
    } else {
        ("POSIX shell integration", "pm", 
         r#"# Always use pm binary for production
    local pm_bin=$(command -v pm)"#)
    };

    format!(
        r#"# Generated by PM v{} - {}
# This function enables directory switching with '{} sw'
#
# Ensure function takes precedence over any existing command
unset {} 2>/dev/null

{}() {{
    {}
    
    if [[ "$1" == "sw" || "$1" == "switch" ]]; then
        local pm_output
        pm_output=$("$pm_bin" "$@" 2>&1)
        local pm_status=$?
        
        if [[ $pm_status -eq 0 ]]; then
            # Extract directory from PM output
            local new_dir
            new_dir=$(echo "$pm_output" | grep "Switched to:" | sed 's/.*Switched to: //')
            if [[ -n "$new_dir" && -d "$new_dir" ]]; then
                cd "$new_dir"
                echo "üìÅ Changed directory to: $new_dir"
            else
                echo "$pm_output"
            fi
        else
            echo "$pm_output"
        fi
        
        return $pm_status
    else
        "$pm_bin" "$@"
    fi
}}"#,
        env!("CARGO_PKG_VERSION"),
        shell_name,
        function_name,
        function_name,
        function_name,
        binary_logic
    )
}

/// Setup Zsh shell integration
async fn setup_zsh_integration() -> Result<()> {
    let config_dir = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not find home directory"))?
        .join(".config/pm");
    
    let zsh_file_path = config_dir.join("pm.zsh");
    let zshrc_path = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not find home directory"))?
        .join(".zshrc");
    
    // Create config directory if it doesn't exist
    fs::create_dir_all(&config_dir).await?;
    
    // Handle existing pm.zsh file conflict
    if zsh_file_path.exists() {
        let existing_content = fs::read_to_string(&zsh_file_path).await?;
        if !existing_content.contains("# Generated by PM v") {
            // User-created file, ask for confirmation
            let should_overwrite = Confirm::new("Existing pm.zsh file found. Overwrite?")
                .with_default(false)
                .prompt()?;
            
            if !should_overwrite {
                println!("‚ùå Zsh integration setup cancelled");
                return Ok(());
            }
            
            // Backup existing file
            let backup_path = zsh_file_path.with_extension("zsh.backup");
            fs::copy(&zsh_file_path, &backup_path).await?;
            println!("üíæ Backed up existing file to: {}", backup_path.display());
        }
    }
    
    // Create the Zsh function file
    let zsh_content = create_posix_shell_function_content(false); // Production mode
    fs::write(&zsh_file_path, zsh_content).await?;
    
    // Add source line to .zshrc if it doesn't exist
    let source_line = "source ~/.config/pm/pm.zsh";
    let mut needs_source_line = true;
    
    if zshrc_path.exists() {
        let zshrc_content = fs::read_to_string(&zshrc_path).await?;
        if zshrc_content.contains(source_line) || zshrc_content.contains(". ~/.config/pm/pm.zsh") {
            needs_source_line = false;
        }
    }
    
    if needs_source_line {
        let source_comment = "\n# PM (Project Manager) shell integration\n";
        let source_content = format!("{}{}\n", source_comment, source_line);
        
        if zshrc_path.exists() {
            // Append to existing .zshrc
            let mut existing_content = fs::read_to_string(&zshrc_path).await?;
            existing_content.push_str(&source_content);
            fs::write(&zshrc_path, existing_content).await?;
        } else {
            // Create new .zshrc
            fs::write(&zshrc_path, source_content).await?;
        }
        
        println!("üìù Added source line to .zshrc");
    }
    
    let binary_name = utils::get_binary_name();
    println!("üêö Zsh shell integration installed successfully");
    println!("   Function file: {}", zsh_file_path.display());
    println!("   Sourced from: {}", zshrc_path.display());
    println!("   Usage: {} sw <project> will now change your shell directory", binary_name);
    
    Ok(())
}

/// Setup Bash shell integration
async fn setup_bash_integration() -> Result<()> {
    let config_dir = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not find home directory"))?
        .join(".config/pm");
    
    let bash_file_path = config_dir.join("pm.bash");
    let bashrc_path = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not find home directory"))?
        .join(".bashrc");
    
    // Create config directory if it doesn't exist
    fs::create_dir_all(&config_dir).await?;
    
    // Handle existing pm.bash file conflict
    if bash_file_path.exists() {
        let existing_content = fs::read_to_string(&bash_file_path).await?;
        if !existing_content.contains("# Generated by PM v") {
            // User-created file, ask for confirmation
            let should_overwrite = Confirm::new("Existing pm.bash file found. Overwrite?")
                .with_default(false)
                .prompt()?;
            
            if !should_overwrite {
                println!("‚ùå Bash integration setup cancelled");
                return Ok(());
            }
            
            // Backup existing file
            let backup_path = bash_file_path.with_extension("bash.backup");
            fs::copy(&bash_file_path, &backup_path).await?;
            println!("üíæ Backed up existing file to: {}", backup_path.display());
        }
    }
    
    // Create the Bash function file
    let bash_content = create_posix_shell_function_content(false); // Production mode
    fs::write(&bash_file_path, bash_content).await?;
    
    // Add source line to .bashrc if it doesn't exist
    let source_line = "source ~/.config/pm/pm.bash";
    let mut needs_source_line = true;
    
    if bashrc_path.exists() {
        let bashrc_content = fs::read_to_string(&bashrc_path).await?;
        if bashrc_content.contains(source_line) || bashrc_content.contains(". ~/.config/pm/pm.bash") {
            needs_source_line = false;
        }
    }
    
    if needs_source_line {
        let source_comment = "\n# PM (Project Manager) shell integration\n";
        let source_content = format!("{}{}\n", source_comment, source_line);
        
        if bashrc_path.exists() {
            // Append to existing .bashrc
            let mut existing_content = fs::read_to_string(&bashrc_path).await?;
            existing_content.push_str(&source_content);
            fs::write(&bashrc_path, existing_content).await?;
        } else {
            // Create new .bashrc
            fs::write(&bashrc_path, source_content).await?;
        }
        
        println!("üìù Added source line to .bashrc");
    }
    
    let binary_name = utils::get_binary_name();
    println!("üêö Bash shell integration installed successfully");
    println!("   Function file: {}", bash_file_path.display());
    println!("   Sourced from: {}", bashrc_path.display());
    println!("   Usage: {} sw <project> will now change your shell directory", binary_name);
    
    Ok(())
}

/// Setup shell integration with backup support
pub async fn setup_shell_integration_with_backup(
    skip: bool,
    replace: bool,
) -> Result<Option<BackupEntry>> {
    let shell_type = detect_shell();
    
    // Collect existing shell integration files that need backup
    let mut files_to_backup = Vec::new();
    
    match shell_type {
        ShellType::Fish => {
            let fish_file = get_fish_function_path();
            if fish_file.exists() {
                files_to_backup.push(fish_file);
            }
        }
        ShellType::Zsh => {
            let zsh_file = get_zsh_integration_path()?;
            if zsh_file.exists() {
                files_to_backup.push(zsh_file);
            }
        }
        ShellType::Bash => {
            let bash_file = get_bash_integration_path()?;
            if bash_file.exists() {
                files_to_backup.push(bash_file);
            }
        }
        ShellType::Unknown => {
            println!("‚ùì Unknown shell detected, skipping shell integration");
            return Ok(None);
        }
    }
    
    // Handle backup if files exist
    let backup_entry = if !files_to_backup.is_empty() {
        handle_shell_integration_conflict(&files_to_backup, skip, replace).await?
    } else {
        None
    };
    
    // Setup shell integration
    match shell_type {
        ShellType::Fish => setup_fish_integration().await?,
        ShellType::Zsh => setup_zsh_integration().await?,
        ShellType::Bash => setup_bash_integration().await?,
        ShellType::Unknown => {} // Already handled above
    }
    
    Ok(backup_entry)
}

/// Handle shell integration file conflicts
async fn handle_shell_integration_conflict(
    files_to_backup: &[PathBuf],
    skip: bool,
    replace: bool,
) -> Result<Option<BackupEntry>> {
    if skip {
        // Non-interactive skip mode
        println!("‚è≠Ô∏è Skipping shell integration setup - files already exist");
        return Ok(None);
    } else if replace {
        // Non-interactive replace mode
        println!("üíæ Creating backup of existing shell integration files...");
        let file_refs: Vec<&Path> = files_to_backup.iter().map(|p| p.as_path()).collect();
        return Ok(Some(create_multi_file_backup(&file_refs, BackupReason::InitConflictResolution).await?));
    } else {
        // Interactive mode: skip/replace/cancel  
        let choices = vec!["Skip (keep existing)", "Replace (backup and recreate)", "Cancel"];
        let choice = Select::new("Shell integration files already exist. What would you like to do?", choices)
            .prompt()?;
        
        match choice {
            "Skip (keep existing)" => {
                println!("‚è≠Ô∏è Keeping existing shell integration");
                return Ok(None);
            }
            "Replace (backup and recreate)" => {
                println!("üíæ Creating backup and recreating shell integration...");
                let file_refs: Vec<&Path> = files_to_backup.iter().map(|p| p.as_path()).collect();
                return Ok(Some(create_multi_file_backup(&file_refs, BackupReason::InitConflictResolution).await?));
            }
            "Cancel" => {
                println!("üö´ Shell integration setup cancelled");
                return Ok(None); // Return None instead of exit for graceful handling
            }
            _ => unreachable!(),
        }
    }
}

/// Get Fish function file path
fn get_fish_function_path() -> PathBuf {
    dirs::home_dir()
        .map(|home| home.join(".config/fish/functions/pm.fish"))
        .unwrap_or_else(|| PathBuf::from("~/.config/fish/functions/pm.fish"))
}

/// Get Zsh integration file path
fn get_zsh_integration_path() -> Result<PathBuf> {
    let config_dir = crate::config::get_config_path()?
        .parent()
        .ok_or_else(|| anyhow!("Failed to get config directory"))?
        .to_path_buf();
    Ok(config_dir.join("pm.zsh"))
}

/// Get Bash integration file path
fn get_bash_integration_path() -> Result<PathBuf> {
    let config_dir = crate::config::get_config_path()?
        .parent()
        .ok_or_else(|| anyhow!("Failed to get config directory"))?
        .to_path_buf();
    Ok(config_dir.join("pm.bash"))
}

/// Add development environment variable to shell files
pub async fn add_dev_env_to_shell_files(binary_path: &Path) -> Result<()> {
    let shell_type = detect_shell();
    
    match shell_type {
        ShellType::Fish => {
            add_dev_env_to_fish(binary_path).await?;
        }
        ShellType::Zsh => {
            add_dev_env_to_zsh(binary_path).await?;
        }
        ShellType::Bash => {
            add_dev_env_to_bash(binary_path).await?;
        }
        ShellType::Unknown => {
            println!("‚ö†Ô∏è  Unknown shell type, cannot add development environment variable");
        }
    }
    
    Ok(())
}

/// Add development environment variable to Fish shell
async fn add_dev_env_to_fish(binary_path: &Path) -> Result<()> {
    let fish_file = get_fish_function_path();
    
    if !fish_file.exists() {
        return Err(anyhow!("Fish integration file not found: {}", fish_file.display()));
    }
    
    let mut content = fs::read_to_string(&fish_file).await?;
    
    // Check if dev env is already added
    if content.contains("# Development environment") {
        println!("üîß Development environment already configured in Fish");
        return Ok(());
    }
    
    // Add development environment variable at the beginning of the function
    let dev_env_section = format!(
        r#"
# Development environment - auto-configured by pm init --dev
set -gx _PM_BINARY "{}"
"#,
        binary_path.display()
    );
    
    // Insert after the comment header but before the function definition
    if let Some(function_start) = content.find("function pm") {
        content.insert_str(function_start, &dev_env_section);
        fs::write(&fish_file, content).await?;
        println!("‚úÖ Added _PM_BINARY to Fish integration: {}", fish_file.display());
    } else {
        return Err(anyhow!("Could not find function definition in Fish file"));
    }
    
    Ok(())
}

/// Add development environment variable to Zsh shell
async fn add_dev_env_to_zsh(binary_path: &Path) -> Result<()> {
    let zsh_file = get_zsh_integration_path()?;
    
    if !zsh_file.exists() {
        return Err(anyhow!("Zsh integration file not found: {}", zsh_file.display()));
    }
    
    let mut content = fs::read_to_string(&zsh_file).await?;
    
    // Check if dev env is already added
    if content.contains("# Development environment") {
        println!("üîß Development environment already configured in Zsh");
        return Ok(());
    }
    
    // Add development environment variable at the beginning
    let dev_env_section = format!(
        r#"# Development environment - auto-configured by pm init --dev
export _PM_BINARY="{}"

"#,
        binary_path.display()
    );
    
    // Insert after the comment header
    if let Some(insert_pos) = content.find("# Environment Variables:") {
        // Find end of the comment section
        if let Some(end_pos) = content[insert_pos..].find('\n') {
            let actual_pos = insert_pos + end_pos + 1;
            content.insert_str(actual_pos, &dev_env_section);
        } else {
            content.insert_str(insert_pos, &dev_env_section);
        }
    } else {
        // Insert at the beginning if no environment variables section found
        content.insert_str(0, &dev_env_section);
    }
    
    fs::write(&zsh_file, content).await?;
    println!("‚úÖ Added _PM_BINARY to Zsh integration: {}", zsh_file.display());
    
    Ok(())
}

/// Add development environment variable to Bash shell
async fn add_dev_env_to_bash(binary_path: &Path) -> Result<()> {
    let bash_file = get_bash_integration_path()?;
    
    if !bash_file.exists() {
        return Err(anyhow!("Bash integration file not found: {}", bash_file.display()));
    }
    
    let mut content = fs::read_to_string(&bash_file).await?;
    
    // Check if dev env is already added
    if content.contains("# Development environment") {
        println!("üîß Development environment already configured in Bash");
        return Ok(());
    }
    
    // Add development environment variable at the beginning
    let dev_env_section = format!(
        r#"# Development environment - auto-configured by pm init --dev
export _PM_BINARY="{}"

"#,
        binary_path.display()
    );
    
    // Insert after the comment header
    if let Some(insert_pos) = content.find("# Environment Variables:") {
        // Find end of the comment section
        if let Some(end_pos) = content[insert_pos..].find('\n') {
            let actual_pos = insert_pos + end_pos + 1;
            content.insert_str(actual_pos, &dev_env_section);
        } else {
            content.insert_str(insert_pos, &dev_env_section);
        }
    } else {
        // Insert at the beginning if no environment variables section found
        content.insert_str(0, &dev_env_section);
    }
    
    fs::write(&bash_file, content).await?;
    println!("‚úÖ Added _PM_BINARY to Bash integration: {}", bash_file.display());
    
    Ok(())
}


/// Setup development shell integration for _pm
pub async fn setup_dev_shell_integration() -> Result<()> {
    let shell_type = detect_shell();
    
    match shell_type {
        ShellType::Fish => setup_dev_fish_integration().await,
        ShellType::Zsh => setup_dev_zsh_integration().await,
        ShellType::Bash => setup_dev_bash_integration().await,
        ShellType::Unknown => {
            println!("‚ùì Unknown shell detected for development mode");
            println!("üí° Current shell: {}", std::env::var("SHELL").unwrap_or_default());
            println!("üí° Manual setup may be required");
            Ok(())
        }
    }
}

/// Setup development Fish shell integration for _pm
async fn setup_dev_fish_integration() -> Result<()> {
    let fish_functions_dir = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not find home directory"))?
        .join(".config/fish/functions");
    
    fs::create_dir_all(&fish_functions_dir).await?;
    
    let pm_dev_fish_path = fish_functions_dir.join("_pm.fish");
    let pm_dev_fish_content = create_fish_function_content(true); // Development mode
    
    fs::write(&pm_dev_fish_path, pm_dev_fish_content).await?;
    
    println!("üê† Fish development shell integration installed");
    println!("   Function file: {}", pm_dev_fish_path.display());
    println!("   Usage: {} sw <project> will now change your shell directory", utils::get_binary_name());
    
    Ok(())
}

/// Setup development Zsh shell integration for _pm
async fn setup_dev_zsh_integration() -> Result<()> {
    let config_dir = crate::config::get_config_dir()?;
    fs::create_dir_all(&config_dir).await?;
    
    let zsh_dev_file_path = config_dir.join("_pm.zsh");
    let zshrc_path = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not find home directory"))?
        .join(".zshrc");
    
    // Create the development Zsh function file
    let zsh_dev_content = create_posix_shell_function_content(true); // Development mode
    fs::write(&zsh_dev_file_path, zsh_dev_content).await?;
    
    // Add source line to .zshrc if it doesn't exist
    let source_line = format!("source {}", zsh_dev_file_path.display());
    let mut needs_source_line = true;
    
    if zshrc_path.exists() {
        let zshrc_content = fs::read_to_string(&zshrc_path).await?;
        if zshrc_content.contains(&source_line) {
            needs_source_line = false;
        }
    }
    
    if needs_source_line {
        let source_comment = "\n# PM Development shell integration\n";
        let source_content = format!("{}{}\n", source_comment, source_line);
        
        if zshrc_path.exists() {
            let mut existing_content = fs::read_to_string(&zshrc_path).await?;
            existing_content.push_str(&source_content);
            fs::write(&zshrc_path, existing_content).await?;
        } else {
            fs::write(&zshrc_path, source_content).await?;
        }
        
        println!("üìù Added source line to ~/.zshrc");
    }
    
    println!("üîß Zsh development shell integration installed");
    println!("   Function file: {}", zsh_dev_file_path.display());
    println!("   Usage: {} sw <project> will now change your shell directory", utils::get_binary_name());
    println!("   Run: source ~/.zshrc or restart your shell");
    
    Ok(())
}

/// Setup development Bash shell integration for _pm
async fn setup_dev_bash_integration() -> Result<()> {
    let config_dir = crate::config::get_config_dir()?;
    fs::create_dir_all(&config_dir).await?;
    
    let bash_dev_file_path = config_dir.join("_pm.bash");
    let bashrc_path = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not find home directory"))?
        .join(".bashrc");
    
    // Create the development Bash function file
    let bash_dev_content = create_posix_shell_function_content(true); // Development mode
    fs::write(&bash_dev_file_path, bash_dev_content).await?;
    
    // Add source line to .bashrc if it doesn't exist
    let source_line = format!("source {}", bash_dev_file_path.display());
    let mut needs_source_line = true;
    
    if bashrc_path.exists() {
        let bashrc_content = fs::read_to_string(&bashrc_path).await?;
        if bashrc_content.contains(&source_line) {
            needs_source_line = false;
        }
    }
    
    if needs_source_line {
        let source_comment = "\n# PM Development shell integration\n";
        let source_content = format!("{}{}\n", source_comment, source_line);
        
        if bashrc_path.exists() {
            let mut existing_content = fs::read_to_string(&bashrc_path).await?;
            existing_content.push_str(&source_content);
            fs::write(&bashrc_path, existing_content).await?;
        } else {
            fs::write(&bashrc_path, source_content).await?;
        }
        
        println!("üìù Added source line to ~/.bashrc");
    }
    
    println!("üîß Bash development shell integration installed");
    println!("   Function file: {}", bash_dev_file_path.display());
    println!("   Usage: {} sw <project> will now change your shell directory", utils::get_binary_name());
    println!("   Run: source ~/.bashrc or restart your shell");
    
    Ok(())
}